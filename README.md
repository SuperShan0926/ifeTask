# ifeTask
百度前端学院task，没来得及报名自己做着玩吧~
##CSS布局
---
###1.两列布局(一列固定一列自适应)

####法一
因为未涉及浮动div的元素有高度时宽度为自适应，而浮动的div元素
会导致宽度跟实际内容有关需要设定宽度值，可以`float left`而另一个处于文档流中的div左margin值为第一个div宽度即可。

####法二
如果一个div浮动影响到其他div，由BFC特性，BFC的区域不会与float box叠加。可以设置被影响的div为overflow－hidden。实现两列布局。

---
##BFC详解：
>BFC就是“块级格式化上下文”的意思，创建了 BFC的元素就是一个独立的盒子，不过只有Block-level box可以参与创建BFC， 它规定了内部的Block-level Box如何布局，并且与这个独立盒子里的布局不受外部影响，当然它也不会影响到外面的元素。

####BFC有以下特性：

1.内部的Box会在垂直方向，从顶部开始一个接一个地放置。
2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生叠加
3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
4.BFC的区域不会与float box叠加。
5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。
6.计算BFC的高度时，浮动元素也参与计算。

####触发BFC的条件:

1.float 除了none以外的值
2.overflow 除了visible 以外的值（hidden，auto，scroll ）
3.display (table-cell，table-caption，inline-block, flex, inline-flex)
4.position值为（absolute，fixed）
5.fieldset元素

####实际应用：

##### 1.解决margin叠加问题 

会产生垂直方向像素叠加。
```
<p>
    hello world
</p>
<p>
    hello world
</p>
<p>
    hello world
</p>

p {
        color:black;
        background: #FF0000;
        width: 200px;
        line-height: 100px;
        text-align:center;
        margin: 50px;
    }

```
解决办法：

```
<div class="BFC">
    <p>
    hello world
    </p>
</div>
 
<p>
    hello world
</p>
<p>
    hello world
</p>

.BFC{
    overflow:hidden;
}
p{
    color:black;
    background:#F00;
    line-height:100px;
    width:200px;
    text-align:center;
    margin:50px;
}
```
##### 2.实现两列布局。

如上。

##### 3.计算BFC高度时，浮动元素也参与计算，可用于闭合浮动。

父div在子div浮动的时候，通过ov-h触发BFC即可闭合浮动
如下自适应红蓝浮动布局。


**个人的一点理解**：一个父层div由子层div撑开时，子层设置margintop
并不会导致其距离父层顶端一定距离，因为父层由子层撑开，而当父层设置ov——h会创建BFC，独立上下文，此时子层margin－top有效，而子层和父层对应同级作用域的块会有margin重叠，但是子层和父层又有margin－top距离，所以忽略父层看子层div和父层同级块的距离变大了，这就是为什么上面例子解决了margin重叠的原理。
---

###2.三列布局
1.左右浮动＋中间一列不浮动左右margin值。
2.左右绝对定位＋中间一列不浮动左右margin值
3.####负margin
三列均设置浮动，左右列父层div设置50%（假设300px）宽度均左移300px，
中间列设置宽度300*2，然后左右子层div右移动300px还原到原位置，实际长度600+600+300 = 1500，因为右列左margin导致中间列被盖住了一块


>position属性详解

###绝对定位（Absolute Positioning）

绝对定位的元素会完全地从常规文档流中脱离。对于包围它的元素而言，它会将该绝对定位元素视为不存在。就好像 display 属性被设为 none 一样。如果你想要保持它所占有的位置而不被其他元素所填充，那么你需要使用其他的定位方式。

你可以通过 top, right, bottom, 和 left 四个属性来设置绝对定位元素的位置。但你通常只会设置它们其中的两个，top 或者 bottom，以及 left 或者 right。默认地它们的值都为 auto。

弄明白绝对定位的关键是知道它的起点在哪里。如果 top 被设置为20px那么你要知道这20px是从哪里开始计算的。

一个绝对定位的元素的起点位置是相对于它的第一个 position 值不为 static 的父元素而言的。如果在它的父元素链上没有满足条件的父元素，那么绝对定位元素则会相对于文档窗口来进行定位。哈！

关于“相对”这个概念你或许有点迷惑，尤其是还有一个叫相对定位的东西，这是我们还没有讲到的。

当你在一个元素的样式上设置 position:absolute 意味着需要考虑父元素，并且如果父元素的 position 值不为 static ，那么绝对定位元素的起点为父元素的左上角位置。

如果父元素没有应用除了 static 以外的 position 定位，那么它会检查父元素的父元素是否有应用非 static 定位。如果该元素应用了定位，那么它的左上角便会成为绝对元素的起点位置。如果没有则会继续向上遍历DOM直到找到一个定位元素或者寻找失败以到达最外层的浏览器窗口。

###相对定位（Relative Positioning）

相对定位的元素也是根据 top, right, bottom, 和 left 四个属性来决定自己的位置的。但只是相对于它们原来所处于的位置进行移动。在某种意义上来说，为元素设置相对定位和为元素添加 margin 有点相似，但也有一个重要的区别。区别就是在围绕在相对定位元素附近的元素会忽略相对定位元素的移动。

我们可以把它看做是一张图片的重像从真实的图片的位置开始进行了一点移动。它原始图片所占据的位置仍然保留，但我们已经没法再看到它，只能看到它的重像。这样就让元素之间可以进行位置的重叠，因为相对定位元素能够移动到其他元素所占据的空间中。

相对定位元素离开了正常文档流，但仍然影响着围绕着它的元素。那些元素表现地就好像这个相对定位元素仍然在正常文档流当中。

我们无需再追问这个相对的位置是在哪里。因为这个相对位置很显然是正常的文档流。相对定位有点儿像为元素添加了 margin ，对相邻元素来说却像是什么都没发生过。但实际上并没有增加任何的 margin 。

###固定定位（Fixed Positioning）

固定定位的行为类似于绝对定位，但也有一些不同的地方。

首先，固定定位总是相对于浏览器窗口来进行定位的，并且通过哪些属性的 top, right, bottom, 和 left 属性来决定其位置。它抛弃了它的父元素，它就是定位中表现地有点儿反叛。。

第二个不同点是其在名字上是继承的。固定定位的元素是固定的。它们并不随着页面的滚动而移动。你可以告诉元素它所处的位置并永远不再移动。噢~好像还挺乖巧的。

在某种意义上说固定定位元素有点儿类似固定的背景图片，只不过它的外层容器块总是浏览器窗口罢了。如果你在 body 中设置一个背景图片那么它与一个固定定位的元素的行为时非常像的，只不过在位置上的精度会略少一些。

背景图片也不能改变其在第三个维度的大小，也因而带来了 z-index 属性。
